package replay

import (
	"encoding/hex"
	"fmt"
	"math/big"
	"math/rand"
	"reflect"
	"strings"

	"github.com/ethereum/go-ethereum/cmd/crysol/abi"

	"github.com/ethereum/go-ethereum/cmd/crysol/fuzz"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/research"
	"github.com/ethereum/go-ethereum/taint-core/vm"
)

type BugReport struct {
	Type         string
	Contract     common.Address
	Function     string
	AttackVector []AttackTransaction
}

func (b BugReport) String() string {
	ret := "Type:" + b.Type + ";Function" + b.Function + ";"
	for _, i := range b.AttackVector {
		ret = ret + "{" + i.String() + "}"
	}
	return ret
}

type AttackTransaction struct {
	message   string
	arguments map[string]interface{}
}

func (a AttackTransaction) String() string {
	ret := a.message + " Args:["
	for name, value := range a.arguments {
		ret += name + ":" + fmt.Sprintf("%v", value) + ";"
	}
	ret += ";"
	return ret
}

func Fuzz(tx fuzz.TxSeedItem) (ret []BugReport) {
	if tx.Substate.Message.To == nil {
		return nil
	}
	ret = make([]BugReport, 0)
	var bug []BugReport
	var err error
	if len(tx.CryptoCalls.PrecompiledCalls[common.HexToAddress("0x1")]) > 0 {
		bug, err = FuzzSingleContractSignatureReplay(tx, true)
		if err == nil {
			ret = append(ret, bug...)
		}
		bug, err = FuzzCrossContractSignatureReplay(tx, true)
		if err == nil {
			ret = append(ret, bug...)
		}
		bug, err = FuzzSignatureMalleability(tx, true)
		if err == nil {
			ret = append(ret, bug...)
		}
		bug, err = FuzzSignatureFrontRunning(tx, true)
		if err == nil {
			ret = append(ret, bug...)
		}
		bug, err = FuzzInsufficientSignatureVerification(tx, true)
		if err == nil {
			ret = append(ret, bug...)
		}
	}
	bug, err = FuzzHashCollision_ABI(tx, true)
	if err == nil {
		ret = append(ret, bug...)
	}
	bug, err = FuzzWeakRandomness(tx, true)
	if err == nil {
		ret = append(ret, bug...)
	}

	bug, err = FuzzMerkleProofReplay(tx, true)
	if err == nil {
		ret = append(ret, bug...)
	}

	bug, err = FuzzMerkleProofFrontRunning(tx, true)
	if err == nil {
		ret = append(ret, bug...)
	}

	return ret
}

func FuzzSingleContractSignatureReplay(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstOutputAlloc   research.SubstateAlloc
		secondOutputAlloc  research.SubstateAlloc
		firstReplayResult  replayResult
		secondReplayResult replayResult
	)

	// Replay the orgiginal message
	firstTempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := firstTempAlloc[originalMessage.From]
	if !exist {
		firstTempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		firstTempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		firstTempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, firstTempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	// if the original transaction didn't call ecrecover / Failed, return
	if len(firstReplayResult.GetEcrecoverCalls()) == 0 || !firstReplayResult.GetStatus() {
		return nil, err
	}

	research.MergeOutputSubstateWithInputSubstate(&firstOutputAlloc, firstTempAlloc, false)

	for i := 0; i < fuzz.FuzzNumberPerOracle; i++ {
		SecondTempAlloc := firstOutputAlloc.Copy()
		tempEnv = *env

		// Generate a new message with the same signature (the other params & msg.sender might differ )
		replayMessage := fuzz.Mutator_SingleSignatureReplay(tx)
		newAddr := replayMessage.From()
		// Add balance to prevent gas error
		tenEther, _ = new(big.Int).SetString("10000000000000000000", 0)
		acc, exist = SecondTempAlloc[newAddr]

		if !exist {
			SecondTempAlloc[newAddr] = research.NewSubstateAccount(0, tenEther, nil)
			replayMessage.SetNonce(0)
		} else {
			SecondTempAlloc[newAddr].Balance.Add(tenEther, acc.Balance)
			replayMessage.SetNonce(uint64(acc.Nonce))
		}
		if secondOutputAlloc, secondReplayResult, err = replaySingleTx(block, txIndex+1, SecondTempAlloc, tempEnv, replayMessage); err != nil {
			return nil, err
		}

		// Patterns for inter-contract signature replay: 1. both txs succeed and change the storage states 2. ecrecover passes (with the same input) 3. The replayed signature is not generated by the msg.sender (to reduce false positive) 4. there is no replay protector
		if log && firstReplayResult.GetStatus() && secondReplayResult.GetStatus() && !SecondTempAlloc.StorageNotChangedby(secondOutputAlloc) && len(firstReplayResult.GetEcrecoverCalls()) > 0 && len(secondReplayResult.GetEcrecoverCalls()) > 0 {
			vulnerableCall := SameEcrecoverInputAndOutput_NotFromMsgSender(firstReplayResult.GetEcrecoverCalls(), secondReplayResult.GetEcrecoverCalls(), originalMessage.From)
			if len(vulnerableCall) == 0 {
				return nil, err
			}
			vulnerableContract := vulnerableCall[0].FromAddr

			if SameReplayProtector(firstReplayResult.GetReplayProtector(), secondReplayResult.GetReplayProtector()) {
				return bugs, nil
			}
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, replayMessage.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: replayMessage.String(), arguments: arguments})

			bugs = append(bugs, BugReport{Contract: vulnerableContract, Type: "Single-Contract Signature Replay", Function: tx.FunctionSelector, AttackVector: attackVector})

			return bugs, nil
		}
	}

	return nil, nil

}

func FuzzSignatureFrontRunning(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstOutputAlloc   research.SubstateAlloc
		secondOutputAlloc  research.SubstateAlloc
		firstReplayResult  replayResult
		secondReplayResult replayResult
	)

	// Replay the orgiginal message
	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	// if the original transaction didn't call ecrecover / Failed, pass
	if len(firstReplayResult.GetEcrecoverCalls()) == 0 || !firstReplayResult.GetStatus() {
		return nil, err
	}

	for i := 0; i < fuzz.FuzzNumberPerOracle; i++ {
		// Front Running Signature Replay: Same Signature, Different Tx Sender => Different Results
		tempAlloc = tx.GlobalStorage.Copy()
		tempEnv = *env

		// Insert a front-running tx before the historical transaction, using a different msg.sender but with the same signature (grabbed from the pending tx pool)
		replayMessage := fuzz.Mutator_FrontRunningSignatureReplay(tx)
		newAddr := replayMessage.From()
		// Add balance to prevent gas error
		tenEther, _ = new(big.Int).SetString("10000000000000000000", 0)
		acc, exist = tempAlloc[newAddr]

		if !exist {
			tempAlloc[newAddr] = research.NewSubstateAccount(0, tenEther, nil)
			replayMessage.SetNonce(0)
		} else {
			tempAlloc[newAddr].Balance.Add(tenEther, acc.Balance)
			replayMessage.SetNonce(uint64(acc.Nonce))
		}
		if secondOutputAlloc, secondReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, replayMessage); err != nil {
			return nil, err
		}

		// Patterns for front-running signature replay: 1. both txs succeed but the storage states change differently 2. ecrecover passes (with the same input)
		if log && firstReplayResult.GetStatus() && secondReplayResult.GetStatus() && !firstOutputAlloc.StorageEqual(secondOutputAlloc) && !tx.GlobalStorage.StorageNotChangedby(secondOutputAlloc) && !tx.GlobalStorage.StorageNotChangedby(firstOutputAlloc) && len(firstReplayResult.GetEcrecoverCalls()) > 0 && len(secondReplayResult.GetEcrecoverCalls()) > 0 {
			vulnerableCall := SameEcrecoverInputAndOutput(firstReplayResult.GetEcrecoverCalls(), secondReplayResult.GetEcrecoverCalls())
			if len(vulnerableCall) == 0 {
				return nil, nil
			}
			vulnerableContract := vulnerableCall[0].FromAddr
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, replayMessage.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: replayMessage.String(), arguments: arguments})
			bugs = append(bugs, BugReport{Contract: vulnerableContract, Type: "Signature Front-Running", Function: tx.FunctionSelector, AttackVector: attackVector})
			return bugs, nil
		}
	}

	return nil, nil

}

func FuzzSignatureMalleability(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstReplayResult replayResult
		firstOutputAlloc  research.SubstateAlloc
	)

	// Replay the orgiginal message
	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	// if the original transaction didn't call ecrecover / Failed, return
	if len(firstReplayResult.GetEcrecoverCalls()) == 0 || !firstReplayResult.GetStatus() || tx.GlobalStorage.StorageNotChangedby(firstOutputAlloc) {
		return nil, err
	}

	// Patterns for signature malleability: 1. call ecrecover 2. didn't check s < secp2561N/2
	if len(firstReplayResult.GetEcrecoverCalls()) > 0 && !firstReplayResult.GetMalleabilityProtector() {
		arguments := make(map[string]interface{})
		_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
		attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})
		bugs = append(bugs, BugReport{Contract: firstReplayResult.GetEcrecoverCalls()[0].FromAddr, Type: "Signature Malleability", Function: tx.FunctionSelector, AttackVector: attackVector})
		return bugs, nil
	}
	return nil, err

}

func FuzzCrossContractSignatureReplay(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	// Replay the orgiginal message
	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	var cryptoAPIcalls fuzz.CryptoAPICalls
	var outputAlloc research.SubstateAlloc
	if cryptoAPIcalls, _, outputAlloc, err = replayTx(block, txIndex, &tx.Substate, tx.StorageTaints); err != nil {
		return nil, err
	}

	if tx.GlobalStorage.StorageNotChangedby(outputAlloc) {
		return nil, err
	}

	// Patterns for cross-contract signature replay: the signature 'hash' does not depends on (\ie, the pre-image contains the contract address) the contract address
	for _, ecrecoverCall := range cryptoAPIcalls.PrecompiledCalls[common.HexToAddress("0x01")] {
		if vm.ContainsContractAddressTaints(vm.MergeTaintList(ecrecoverCall.ParamContentTaints)) {
			continue
		} else if len(fuzz.InitEIP712Seperator) > 0 {
			for _, taint := range vm.MergeTaintList(ecrecoverCall.ParamContentTaints) {
				if vm.IsKECCAK256Taint(taint) {
					if len(cryptoAPIcalls.Sha3Calls) > taint-vm.TaintHashResultOffset {
						sha3 := cryptoAPIcalls.Sha3Calls[taint-vm.TaintHashResultOffset]
						for _, protector := range fuzz.InitEIP712Seperator {
							if strings.Contains(sha3.Parameters, protector) {
								return nil, nil
							}
						}
					}
				}
			}
		} else {
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})
			bugs = append(bugs, BugReport{Contract: ecrecoverCall.FromAddr, Type: "Cross-Contract Signature Replay", Function: tx.FunctionSelector, AttackVector: attackVector})
			return bugs, nil
		}
	}
	return nil, nil

}

// Alias for Unchecked Ecrecover Return Value
func FuzzInsufficientSignatureVerification(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstOutputAlloc   research.SubstateAlloc
		secondOutputAlloc  research.SubstateAlloc
		firstReplayResult  replayResult
		secondReplayResult replayResult
	)

	// Replay the orgiginal message
	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	// if the original transaction didn't call ecrecover / Failed, pass
	if len(firstReplayResult.GetEcrecoverCalls()) == 0 || !firstReplayResult.GetStatus() {
		return nil, err
	}

	for i := 0; i < fuzz.FuzzNumberPerOracle; i++ {
		tempAlloc = tx.GlobalStorage.Copy()
		tempEnv = *env

		// Generate a random singature (i.e., an invalid signature) and check whether it can pass the signature verification
		newMsg := fuzz.Mutator_InsufficientSignatureVerification(tx)
		if newMsg.String() == originalMsg.String() {
			continue
		}
		newAddr := newMsg.From()
		// Add balance to prevent gas error
		tenEther, _ = new(big.Int).SetString("10000000000000000000", 0)
		acc, exist = tempAlloc[newAddr]

		if !exist {
			tempAlloc[newAddr] = research.NewSubstateAccount(0, tenEther, nil)
			newMsg.SetNonce(0)
		} else {
			tempAlloc[newAddr].Balance.Add(tenEther, acc.Balance)
			newMsg.SetNonce(uint64(acc.Nonce))
		}
		if secondOutputAlloc, secondReplayResult, err = replaySingleTx(block, txIndex+1, tempAlloc, tempEnv, newMsg); err != nil {
			return nil, err
		}

		// if the original transaction didn't call ecrecover / Failed, pass
		if len(secondReplayResult.GetEcrecoverCalls()) == 0 || !secondReplayResult.GetStatus() {
			return nil, err
		}

		// Patters for Insufficient Signature Verification: 1. Signature is invalid 2. Tx Passes 3. Tx makes storage changes
		if log && firstReplayResult.GetStatus() && secondReplayResult.GetStatus() && !tx.GlobalStorage.StorageNotChangedby(firstOutputAlloc) && !tx.GlobalStorage.StorageNotChangedby(secondOutputAlloc) && InvalidEcrecover(firstReplayResult.GetEcrecoverCalls(), secondReplayResult.GetEcrecoverCalls()) {
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, newMsg.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: newMsg.String(), arguments: arguments})
			bugs = append(bugs, BugReport{Contract: secondReplayResult.GetEcrecoverCalls()[0].FromAddr, Type: "Insufficient Signature Verification", Function: tx.FunctionSelector, AttackVector: attackVector})
			return bugs, nil
		}
	}

	return nil, nil

}

func FuzzHashCollision_ABI(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	FunctionAbi := fuzz.Selector2FunctionABIs[tx.FunctionSelector]
	Params := FunctionAbi.Inputs.NonIndexed()
	if len(Params) <= 1 {
		return nil, nil
	}
	TwoDynamicParams := false

	CollisionArgs := make(map[string]string, 0)

	for i := range Params {
		if i >= 1 && abi.IsDynamicType(Params[i].Type) && abi.IsDynamicType(Params[i-1].Type) {
			TwoDynamicParams = true
			CollisionArgs[Params[i-1].Name] = Params[i].Name

		}
	}
	if !TwoDynamicParams {
		return nil, nil
	}

	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstReplayResult replayResult
	)

	// Replay the orgiginal message
	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if _, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	if firstReplayResult.CryptoCallNumber() == 0 || !firstReplayResult.GetStatus() {
		return nil, err
	}

	HashCalls := make([]vm.CryptoAPICall, 0)
	HashCalls = append(HashCalls, firstReplayResult.sha3Calls...)
	HashCalls = append(HashCalls, firstReplayResult.cryptoPrecompiledCalls[common.HexToAddress("0x1")]...)
	HashCalls = append(HashCalls, firstReplayResult.cryptoPrecompiledCalls[common.HexToAddress("0x2")]...)

	for _, hash := range HashCalls {
		TxIndexs := vm.GetTxInputIndexFromTaints(hash.ParamContentTaints)
		args := make([]string, 0)
		for _, i := range TxIndexs {
			arg := fuzz.ArgumentIndexToArg(i, tx.InputIndex2Arg)
			args = append(args, arg)
		}

		if len(args) > 0 {
			for i := range args {
				if i < len(args)-1 {
					if nextInput, exists := CollisionArgs[args[i]]; !exists {
						continue
					} else {
						if nextInput == args[i+1] {
							params1 := ""
							params2 := ""
							var inputArg1, inputArg2 abi.Argument
							for _, input := range fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs {
								if input.Name == args[i] {
									inputArg1 = input
								}
								if input.Name == args[i+1] {
									inputArg2 = input
								}
							}

							arg1Bytes, ok1 := tx.Argument[args[i]].([]byte)
							if ok1 {
								params1 = common.Bytes2Hex(arg1Bytes)
							} else {
								arg1String, ok1 := tx.Argument[args[i]].(string)
								if ok1 {
									params1 = hex.EncodeToString([]byte(arg1String))
								} else {
									params1Byte, _ := inputArg1.Type.PackwithoutPrefix(reflect.ValueOf(tx.Argument[args[i]]))
									params1 = common.Bytes2Hex(params1Byte)
								}
							}

							arg2Bytes, ok1 := tx.Argument[args[i+1]].([]byte)
							if ok1 {
								params2 = common.Bytes2Hex(arg2Bytes)
							} else {
								arg2String, ok1 := tx.Argument[args[i+1]].(string)
								if ok1 {
									params2 = hex.EncodeToString([]byte(arg2String))
								} else {
									params2Byte, _ := inputArg2.Type.PackwithoutPrefix(reflect.ValueOf(tx.Argument[args[i+1]]))
									params2 = common.Bytes2Hex(params2Byte)
								}

							}

							if params1 == "" || params2 == "" {
								continue
							}

							params := params1 + params2
							// Patterns for Hash Collission: 1. Same Hash (Hash depending on Tx Input) 2. Different Tx Input
							if params1 != "" && params2 != "" && strings.Contains(hash.Parameters, params) {
								if abi.IsSliceType(inputArg1.Type) && abi.IsSliceType(inputArg2.Type) {
									if len(params1) <= 64 && len(params2) <= 64 {
										continue
									}
								}

								arguments := make(map[string]interface{})
								_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
								attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})
								bugs = append(bugs, BugReport{Contract: hash.FromAddr, Type: "Hash Collisions With Dynamic-Length Arguments", Function: tx.FunctionSelector, AttackVector: attackVector})
								return bugs, nil
							}
						}
					}
				}
			}
		}
	}
	return nil, nil
}

func FuzzMerkleProofFrontRunning(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstReplayResult  replayResult
		secondReplayResult replayResult
		firstOutputAlloc   research.SubstateAlloc
		secondOutputAlloc  research.SubstateAlloc
	)

	// Replay the orgiginal message

	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	if len(firstReplayResult.merkleProofCalls) < 4 {
		return nil, err
	}

	for i := 0; i < fuzz.FuzzNumberPerOracle; i++ {
		tempAlloc = tx.GlobalStorage.Copy()
		tempEnv = *env

		// Generate a new message with the same Merkle Proof (the msg.sender differs )
		replayMessage := fuzz.Mutator_MerkleProofFrontRunning(tx)
		newAddr := replayMessage.From()
		// Add balance to prevent gas error
		tenEther, _ = new(big.Int).SetString("10000000000000000000", 0)
		acc, exist = tempAlloc[newAddr]

		if !exist {
			tempAlloc[newAddr] = research.NewSubstateAccount(0, tenEther, nil)
			replayMessage.SetNonce(0)
		} else {
			tempAlloc[newAddr].Balance.Add(tenEther, acc.Balance)
			replayMessage.SetNonce(uint64(acc.Nonce))
		}
		if secondOutputAlloc, secondReplayResult, err = replaySingleTx(block, txIndex+1, tempAlloc, tempEnv, replayMessage); err != nil {
			return nil, err
		}

		if len(secondReplayResult.merkleProofCalls) < 4 {
			return nil, err
		}

		// Patterns for Merkle Proof Front Running: 1. both txs succeed 2. the tx storage states change differently
		if log && firstReplayResult.GetStatus() && secondReplayResult.GetStatus() && !firstOutputAlloc.StorageEqual(secondOutputAlloc) && !tx.GlobalStorage.StorageNotChangedby(secondOutputAlloc) && !tx.GlobalStorage.StorageNotChangedby(firstOutputAlloc) {
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, replayMessage.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: replayMessage.String(), arguments: arguments})
			bugs = append(bugs, BugReport{Contract: secondReplayResult.merkleProofCalls[0].FromAddr, Type: "Merkle Proof Front-Running", Function: tx.FunctionSelector, AttackVector: attackVector})
			return bugs, nil
		}
	}
	return nil, nil
}

func FuzzMerkleProofReplay(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstReplayResult  replayResult
		secondReplayResult replayResult
		firstOutputAlloc   research.SubstateAlloc
		secondOutputAlloc  research.SubstateAlloc
	)

	// Replay the orgiginal message

	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	if len(firstReplayResult.merkleProofCalls) < 4 {
		return nil, err
	}
	NextState := firstOutputAlloc.Copy()
	research.MergeOutputSubstateWithInputSubstate(&NextState, tempAlloc, false)

	for i := 0; i < fuzz.FuzzNumberPerOracle; i++ {
		tempAlloc = NextState.Copy()
		tempEnv = *env

		// Generate a new message with the Merkle Proof (the other params & msg.sender might differ )
		replayMessage := fuzz.Mutator_MerkleProofReplay(tx)
		newAddr := replayMessage.From()
		// Add balance to prevent gas error
		tenEther, _ = new(big.Int).SetString("10000000000000000000", 0)
		acc, exist = tempAlloc[newAddr]

		if !exist {
			tempAlloc[newAddr] = research.NewSubstateAccount(0, tenEther, nil)
			replayMessage.SetNonce(0)
		} else {
			tempAlloc[newAddr].Balance.Add(tenEther, acc.Balance)
			replayMessage.SetNonce(uint64(acc.Nonce))
		}
		if secondOutputAlloc, secondReplayResult, err = replaySingleTx(block, txIndex+1, tempAlloc, tempEnv, replayMessage); err != nil {
			return nil, err
		}

		if len(secondReplayResult.merkleProofCalls) < 4 {
			return nil, err
		}

		// Patterns for Merkle Proof replay: 1. both txs succeed 2. the second tx changes the storage again
		if log && firstReplayResult.GetStatus() && secondReplayResult.GetStatus() && !tx.GlobalStorage.StorageNotChangedby(firstOutputAlloc) && !NextState.StorageNotChangedby(secondOutputAlloc) {
			if SameReplayProtector(firstReplayResult.GetReplayProtector(), secondReplayResult.GetReplayProtector()) {
				return bugs, nil
			}
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, replayMessage.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: replayMessage.String(), arguments: arguments})
			bugs = append(bugs, BugReport{Contract: secondReplayResult.merkleProofCalls[len(secondReplayResult.merkleProofCalls)-1].FromAddr, Type: "Merkle Proof Replay", Function: tx.FunctionSelector, AttackVector: attackVector})

			return bugs, nil
		}
	}
	return nil, nil
}

func FuzzWeakRandomness(tx fuzz.TxSeedItem, log bool) (bugs []BugReport, err error) {
	substate := tx.Substate
	block := uint64(tx.Block)
	txIndex := tx.TxIndex
	env := substate.Env
	originalMessage := substate.Message
	bugs = make([]BugReport, 0)
	attackVector := make([]AttackTransaction, 0)

	var (
		firstReplayResult  replayResult
		secondReplayResult replayResult
		firstOutputAlloc   research.SubstateAlloc
		secondOutputAlloc  research.SubstateAlloc
	)

	// Replay the orgiginal message
	tempAlloc := tx.GlobalStorage.Copy()

	// Add balance to prevent gas error
	tenEther, _ := new(big.Int).SetString("10000000000000000000", 0)
	acc, exist := tempAlloc[originalMessage.From]
	if !exist {
		tempAlloc[originalMessage.From] = research.NewSubstateAccount(0, tenEther, nil)
	} else {
		tempAlloc[originalMessage.From].Balance.Add(tenEther, acc.Balance)
	}
	tempEnv := *env
	originalMsg := types.NewMessage(
		originalMessage.From,
		originalMessage.To,
		tempAlloc[originalMessage.From].Nonce,
		originalMessage.Value,
		originalMessage.Gas,
		originalMessage.GasPrice,
		originalMessage.GasFeeCap,
		originalMessage.GasTipCap,
		originalMessage.Data,
		originalMessage.AccessList,
		false,
	)
	arguments := make(map[string]interface{})
	_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, originalMsg.Data()[4:])
	attackVector = append(attackVector, AttackTransaction{message: originalMsg.String(), arguments: arguments})

	// execute original msg
	if firstOutputAlloc, firstReplayResult, err = replaySingleTx(block, txIndex, tempAlloc, tempEnv, originalMsg); err != nil {
		return nil, err
	}

	if firstReplayResult.CryptoCallNumber() == 0 || !firstReplayResult.GetStatus() {
		return nil, err
	}

	for i := 0; i < 20; i++ {
		tempAlloc = tx.GlobalStorage.Copy()
		tempEnv := research.SubstateEnv{
			Number:      env.Number + uint64(rand.Intn(10)),      // mutate blockNumber
			Timestamp:   env.Timestamp + uint64(rand.Intn(1000)), // mutate Block Timestamp
			Difficulty:  env.Difficulty,
			GasLimit:    env.GasLimit,
			Coinbase:    mutateCoinbase(env.Coinbase),
			BlockHashes: mutateBlocHashes(env.BlockHashes),
			BaseFee:     env.BaseFee,
		}

		replayMessage := originalMsg

		if secondOutputAlloc, secondReplayResult, err = replaySingleTx(block, txIndex+1, tempAlloc, tempEnv, replayMessage); err != nil {
			return nil, err
		}

		if secondReplayResult.CryptoCallNumber() == 0 || !secondReplayResult.GetStatus() {
			return nil, err
		}

		// Patterns for Weak Randomness: 1. Hashing Chain Attributes 2. Chain Attributes Change => Hashes Change 3. the storage changes differ
		if log && !firstOutputAlloc.StorageEqual(secondOutputAlloc) && !tx.GlobalStorage.StorageNotChangedby(secondOutputAlloc) {
			vulnerableCall := DifferentBranchHashInputWithDifferentChainAttributes(firstReplayResult, secondReplayResult)
			if len(vulnerableCall) == 0 {
				return nil, nil
			}
			vulnerableContract := vulnerableCall[0].FromAddr
			arguments := make(map[string]interface{})
			_, _ = fuzz.Selector2FunctionABIs[tx.FunctionSelector].Inputs.UnpackIntoMapWithIndex(arguments, replayMessage.Data()[4:])
			attackVector = append(attackVector, AttackTransaction{message: replayMessage.String(), arguments: arguments})
			bugs = append(bugs, BugReport{Contract: vulnerableContract, Type: "Weak Randomness from Hashing Chain Attributes", Function: tx.FunctionSelector, AttackVector: attackVector})
			return bugs, nil
		}
	}
	return nil, nil
}

func mutateCoinbase(a common.Address) common.Address {
	r := rand.Intn(2)
	if r == 0 {
		return a
	} else {
		addr := make([]byte, 20)
		rand.Read(addr)
		return common.BytesToAddress(addr)
	}
}
func mutateBlocHashes(m map[uint64]common.Hash) map[uint64]common.Hash {
	result := make(map[uint64]common.Hash)
	r := rand.Intn(2)
	if r == 0 {
		return m
	} else {
		for key := range m {
			randHashBytes := make([]byte, 20)
			rand.Read(randHashBytes)
			var h common.Hash
			h.SetBytes(randHashBytes)
			result[key] = h
		}
		return result
	}
}
